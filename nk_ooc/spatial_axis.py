"""SpatialAxis class"""

from datetime import datetime

import numpy as np
from netCDF4 import Dataset

from .utils import class_name, create_dimensions_verify, create_vars


class SpatialAxis:
    """class for spatial axis related quantities"""

    def __init__(self, axisname, edges, units=None, defn_dict_values=None):
        """
        Initialize SpatialAxis object from its edge values.

        The fundamental quantities defining a SpatialAxis are it layer edges.
        All other quantities are derived from these edges.

        Argument Descriptions:
        axisname: name given to axis
        edges: numpy array of edge values
        units: units of edges; assumed to be "m" if not provided
        defn_dict_values: optional defining metadata

        See also: spatial_axis_from_file, spatial_axis_from_defn_dict.
        """

        self.axisname = axisname
        self.edges = edges
        self.units = "m" if units is None else units
        self.defn_dict_values = defn_dict_values

        self.mid = 0.5 * (self.edges[:-1] + self.edges[1:])
        self.delta = self.edges[1:] - self.edges[:-1]
        self.delta_r = 1.0 / self.delta
        self.delta_mid = self.mid[1:] - self.mid[:-1]
        self.delta_mid_r = 1.0 / self.delta_mid

        self.dump_names = {
            "bounds": "_".join([self.axisname, "bounds"]),
            "edges": "_".join([self.axisname, "edges"]),
            "delta": "_".join([self.axisname, "delta"]),
        }

    def __len__(self):
        """length of axis, i.e., number of layers"""
        return len(self.mid)

    def dump(self, fname, caller):
        """write axis information to a netCDF4 file"""

        with Dataset(fname, mode="w", format="NETCDF3_64BIT_OFFSET") as fptr:
            datestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            name = f"{class_name(self)}.dump"
            fptr.history = f"{datestamp}: generated by {name} called from {caller}"

            if self.defn_dict_values is not None:
                fptr.defn_dict_values = self.defn_dict_values

            create_dimensions_verify(fptr, self.dump_dimensions())
            create_vars(fptr, self.dump_vars_metadata())

            self.dump_write(fptr)

    def dump_dimensions(self):
        """return dictionary of dimensions for dumping self to a netCDF4 file"""

        return {
            self.axisname: len(self),
            "nbnds": 2,
            self.dump_names["edges"]: len(self) + 1,
        }

    def dump_vars_metadata(self):
        """variable metadata for dump"""
        res = {}
        res[self.axisname] = {
            "dimensions": (self.axisname,),
            "attrs": {
                "long_name": f"{self.axisname} layer midpoints",
                "units": self.units,
                "bounds": self.dump_names["bounds"],
            },
        }
        res[self.dump_names["bounds"]] = {
            "dimensions": (self.axisname, "nbnds"),
            "attrs": {"long_name": f"{self.axisname} layer bounds"},
        }
        res[self.dump_names["edges"]] = {
            "dimensions": (self.dump_names["edges"],),
            "attrs": {"long_name": f"{self.axisname} layer edges", "units": self.units},
        }
        res[self.dump_names["delta"]] = {
            "dimensions": (self.axisname,),
            "attrs": {
                "long_name": f"{self.axisname} layer thickness",
                "units": self.units,
            },
        }
        return res

    def dump_vals_dict(self):
        """return dict of values for dump"""
        res = {}
        res[self.axisname] = self.mid
        res[self.dump_names["bounds"]] = np.stack(
            (self.edges[:-1], self.edges[1:]), axis=1
        )
        res[self.dump_names["edges"]] = self.edges
        res[self.dump_names["delta"]] = self.delta
        return res

    def dump_write(self, fptr):
        """write variables for dump"""
        for name, vals in self.dump_vals_dict().items():
            fptr.variables[name][:] = vals
        fptr.sync()

    def int_vals_mid(self, vals, axis):
        """
        integrate layer vals (i.e., at layer midpoints)
        axis argument specifies the axis of integration
        """
        if vals.shape[axis] != len(self):
            raise ValueError(f"length mismatch, {vals.shape[axis]} != {len(self)}")
        if axis in (-1, vals.ndim - 1):
            return (self.delta * vals).sum(axis=axis)
        if axis in (-2, vals.ndim - 2):
            return (self.delta[:, np.newaxis] * vals).sum(axis=axis)
        if axis in (-3, vals.ndim - 3):
            return (self.delta[:, np.newaxis, np.newaxis] * vals).sum(axis=axis)
        raise ValueError(f"axis={axis}")

    def remap_linear_interpolant(self, xvals, yvals):
        """
        Conservatively remap piecewise linear interpolant of xvals, yvals to self.
        """

        # In initial pass, compute average of linear interpolant evaluated at edges.
        # This is the correct value for layers not containing x values.
        yvals_at_edges = np.interp(self.edges, xvals, yvals)
        res = 0.5 * (yvals_at_edges[:-1] + yvals_at_edges[1:])

        # Update values in layers containing x values.
        # Note that there may be more than one x value in a given layer.
        # vals_ind is an index whose x value is in layer layer_ind.
        layer_ind = 0
        vals_ind = 0
        while vals_ind < len(xvals):
            # x value to the left of self; skip to next x value
            if xvals[vals_ind] < self.edges[0]:
                vals_ind += 1
                continue

            # x value to the right of self; we're done
            if xvals[vals_ind] >= self.edges[-1]:
                break

            # find layer containing x value
            # self.edges[layer_ind] <= xvals[vals_ind] < self.edges[layer_ind + 1]
            while xvals[vals_ind] >= self.edges[layer_ind + 1]:
                layer_ind += 1

            # contribution from self.edges[layer_ind] <= x < xvals[vals_ind]
            val = 0.5 * (yvals_at_edges[layer_ind] + yvals[vals_ind])
            val_sum = (xvals[vals_ind] - self.edges[layer_ind]) * val

            while (vals_ind < len(xvals)) and (
                xvals[vals_ind] < self.edges[layer_ind + 1]
            ):
                if (vals_ind + 1 < len(xvals)) and (
                    xvals[vals_ind + 1] < self.edges[layer_ind + 1]
                ):
                    # contribution from xvals[vals_ind] <= x < xvals[vals_ind + 1]
                    val = 0.5 * (yvals[vals_ind] + yvals[vals_ind + 1])
                    val_sum += (xvals[vals_ind + 1] - xvals[vals_ind]) * val
                else:
                    # contribution from xvals[vals_ind] <= x < self.edges[layer_ind + 1]
                    val = 0.5 * (yvals[vals_ind] + yvals_at_edges[layer_ind + 1])
                    val_sum += (self.edges[layer_ind + 1] - xvals[vals_ind]) * val
                vals_ind += 1

            res[layer_ind] = val_sum * self.delta_r[layer_ind]

        return res


def spatial_axis_from_file(fname, axisname, edges_varname=None):
    """
    Return a SpatialAxis object initialized from edge values from a file.
    fname: name of netCDF file with edge values
    axisname: name of axis
    edges_varname: name of variable in fname with axis edge values
        If None, then assume edges_varname = f"{axisname}_edges".

    Propagate units from the edges variable in fname, if present.
    and defn_dict, if they are present in the file.
    """

    if edges_varname is None:
        edges_varname = "_".join([axisname, "edges"])

    with Dataset(fname, mode="r") as fptr:
        fptr.set_auto_mask(False)
        edges = fptr.variables[edges_varname][:]
        units = getattr(fptr.variables[edges_varname], "units", None)
        defn_dict_values = getattr(fptr, "defn_dict_values", None)

    return SpatialAxis(axisname, edges, units, defn_dict_values)


def spatial_axis_from_defn_dict(defn_dict):
    """
    Return a SpatialAxis object initialized from a defn_dict.

    Keys in defn_dict that are required to have a value are:
        axisname (str): name of axis
        nlevs (int): number of layers
        edge_start (float): first edge value
        edge_end (float): last edge value

    Exactly one of the following keys is required to have a value:
        delta_ratio_max (float): maximum ratio of layer thicknesses
        delta_start (float): first layer thickness

    Keys in defn_dict that may optionally have a value are:
        units (str): units of axis values
    """

    # ensure required values are set
    for key in ["axisname", "nlevs", "edge_start", "edge_end", "delta_ratio_max"]:
        if defn_dict[key]["value"] is None:
            raise ValueError(f"required value for key {key} not set")

    if (defn_dict["delta_ratio_max"]["value"] is None) == (
        defn_dict["delta_start"]["value"] is None
    ):
        raise ValueError(
            "exactly one of delta_ratio_max and delta_start must have a value"
        )

    axisname = defn_dict["axisname"]["value"]
    edges = _edges_from_defn_dict(defn_dict)
    units = defn_dict["units"]["value"]
    defn_dict_values = "\n".join(
        f'{key}={value["value"]}' for key, value in defn_dict.items()
    )
    return SpatialAxis(axisname, edges, units, defn_dict_values)


def _edges_from_defn_dict(defn_dict):
    """Generate edges from axis specs in defn_dict."""

    nlevs = defn_dict["nlevs"]["value"]

    # polynomial stretching function
    # stretch_fcn(-1)=-1, stretch_fcn'(-1)=0, stretch_fcn''(-1)=0
    # stretch_fcn(1)=1, stretch_fcn'(1)=0, stretch_fcn''(1)=0
    # the mean of stretch_fcn is 0, so adding multiples of it to the thichnesses
    # doesn't change the mean thickness
    coord = np.linspace(-1.0, 1.0, nlevs)
    stretch_fcn = 0.125 * coord * (15 + coord * coord * (3 * coord * coord - 10))

    delta_avg = (1.0 / nlevs) * (
        defn_dict["edge_end"]["value"] - defn_dict["edge_start"]["value"]
    )

    if defn_dict["delta_ratio_max"]["value"] is not None:
        # compute stretch_factor from delta_ratio_max, by solving
        # (delta_avg + stretch_factor) / (delta_avg - stretch_factor) = delta_ratio_max
        delta_ratio_max = defn_dict["delta_ratio_max"]["value"]
        if delta_ratio_max <= 0.0:
            raise ValueError("delta_ratio_max must be > 0.0 to ensure delta > 0.0")
        stretch_factor = delta_avg * (delta_ratio_max - 1) / (delta_ratio_max + 1)
    else:
        # compute stretch_factor from delta_start
        delta_start = defn_dict["delta_start"]["value"]
        if delta_start <= 0.0:
            raise ValueError("delta_start must be > 0.0")
        stretch_factor = delta_avg - delta_start

    delta = delta_avg + stretch_factor * stretch_fcn

    edges = np.empty(1 + nlevs)
    edges[0] = defn_dict["edge_start"]["value"]
    edges[1:] = defn_dict["edge_start"]["value"] + delta.cumsum()

    return edges


def spatial_axis_defn_dict(axisname="depth", trap_unknown=True, **kwargs):
    """
    return a defn_dict suitable for initializing a class object
    dict has additional attributes useful for argparse arguments
    """

    # framework for defn_dict, with no values besides axisname
    defn_dict = {
        "axisname": {"type": str, "help": "axis name", "value": axisname},
        "units": {"type": str, "help": "axis units", "value": None},
        "nlevs": {"type": int, "help": "number of layers", "value": None},
        "edge_start": {"type": float, "help": "start of edges", "value": None},
        "edge_end": {"type": float, "help": "end of edges", "value": None},
        "delta_ratio_max": {
            "type": float,
            "help": "maximum ratio of layer thicknesses",
            "value": None,
        },
        "delta_start": {"type": float, "help": "first layer thickness", "value": None},
    }

    # set item defaults, based on axisname argument
    if axisname.lower() == "depth":
        defn_dict["units"]["value"] = "m"
        defn_dict["nlevs"]["value"] = 30
        defn_dict["edge_start"]["value"] = 0.0
        defn_dict["edge_end"]["value"] = 900.0
        defn_dict["delta_ratio_max"]["value"] = 5.0

    # populate defn_dict with values from kwargs
    for key, value in kwargs.items():
        if key in defn_dict:
            defn_dict[key]["value"] = value
        elif trap_unknown:
            raise ValueError(f"unknown key {key}")

    return defn_dict
